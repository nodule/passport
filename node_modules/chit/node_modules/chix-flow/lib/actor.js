var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var events = require('events');
var Node = require('../lib/node');

var DefaultProvider = require('../lib/context/defaultProvider'), DefaultInputHandler = require('../lib/port/defaultInputHandler');
validateFlow = require('../lib/validate');

var Chiχ;
(function (Chiχ) {
    var Actor = (function (_super) {
        __extends(Actor, _super);
        function Actor() {
            this.inputHandler = new DefaultInputHandler();
            this.nodes = {};
            this.links = {};
            this.instances = {};
            this.inputMap = {};
            this.outputMap = {};
            this.objectMap = {
                nodes: {},
                links: []
            };

            this.on('nodeContext', function (node, defaultContext) {
            });
        }
        Actor.prototype.addMap = function (map) {
            if (typeof map == "undefined")
                throw new Error("map is not defined");
            if (map !== Object(map))
                throw new Error("addMap expects an object");

            validateFlow(map);

            this.map = map;
        };

        Actor.prototype.addNodeDefinition = function (nodeDef, update) {
            if (!this.map.nodeDefinitions.hasOwnProperty(nodeDefs[i].ns)) {
                this.map.nodeDefinitions[nodeDefs[i].ns] = {};
            }

            if (update || !this.map.nodeDefinitions[nodeDefs[i].ns].hasOwnProperty([nodeDefs[i].name])) {
                this.map.nodeDefinitions[nodeDefs[i].ns][nodeDefs[i].name] = nodeDefs[i];
            }
        };

        Actor.prototype.removeNodeDefinition = function (ns, name) {
            if (this.map.nodeDefinitions.hasOwnProperty(ns)) {
                if (this.map.nodeDefinitions[ns].hasOwnProperty(name)) {
                    delete this.map.nodeDefinitions[ns][name];
                }
            }
        };

        Actor.prototype.addNodeDefinitions = function (nodeDefs) {
            var i;
            if (Array.isArray(nodeDefs)) {
                for (i = 0; i < nodeDefs.length; i++) {
                    if (!this.map.nodeDefinitions.hasOwnProperty(nodeDefs[i].ns)) {
                        this.map.nodeDefinitions[nodeDefs[i].ns] = {};
                    }

                    this.map.nodeDefinitions[nodeDefs[i].ns][nodeDefs[i].name] = nodeDefs[i];
                }
            } else {
                this.map.nodeDefinitions = nodeDefs;
            }
        };

        Actor.prototype.addContextProvider = function (provider) {
            this.contextProvider = provider;
        };

        Actor.prototype.createIOMaps = function () {
            var self = this;
            this.map.links.forEach(function (link) {
                if (!self.inputMap[link.source])
                    self.inputMap[link.source] = [];
                self.inputMap[link.source].push(link);

                if (!self.outputMap[link.target])
                    self.outputMap[link.target] = [];
                self.outputMap[link.target].push(link);
            });
        };

        Actor.prototype.output = function (output, node) {
            var i;

            if (this.inputMap.hasOwnProperty(node.id)) {
                if (Object.keys(this.inputMap[node.id]).length) {
                    for (i = 0; i < this.inputMap[node.id].length; i++) {
                        var receiverPort = this.inputMap[node.id][i];

                        if (output.port === receiverPort.out) {
                            var targetNode = this.nodes[receiverPort.target];

                            var data = this.inputHandler.handle(node, targetNode, receiverPort.in, output.out, this.outputMap[receiverPort.target]);

                            if (this.inputHandler.bucketMode && !data) {
                                console.log('BucketMOde');
                            } else {
                                logger.log('info', '%s:%s sending to %s:%s', node.identifier, output.port, this.nodes[receiverPort.target].identifier, receiverPort['in']);

                                var opts = { persist: receiverPort.persist };

                                this.emit('portData', node, output.port, this.nodes[receiverPort.target], receiverPort['in'], opts);

                                this.send(receiverPort.target, receiverPort['in'], data, opts);
                            }
                        }
                    }
                }
            } else {
                logger.log('info', "%s: finished, has no receivers", node.identifier);
            }
        };

        Actor.prototype.send = function (targetId, port, data, opts) {
            this.nodes[targetId].fill(port, data, opts);
        };

        Actor.prototype.createNodes = function () {
            var node, i, j, self = this, iId;

            if (!this.map) {
                throw new Error("createNodes: addMap should be used before calling createNodes");
            }

            this.createIOMaps();

            for (i = 0; i < this.map.nodes.length; i++) {
                node = this.map.nodes[i];

                if (!this.map.nodeDefinitions[node.ns]) {
                    throw new Error("Unknown node definition namespace: " + node.ns);
                }

                if (!this.map.nodeDefinitions[node.ns][node.name]) {
                    throw new Error("Unknown node definition: " + node.ns + ':' + node.name);
                }

                if (!node.id) {
                    throw new Error("Node lacks an id: " + node.ns + ':' + node.name);
                }

                if (!this.map.nodeDefinitions[node.ns][node.name].ports.input) {
                    this.map.nodeDefinitions[node.ns][node.name].ports.input = {};
                }

                if (!this.map.nodeDefinitions[node.ns][node.name].ports.output) {
                    this.map.nodeDefinitions[node.ns][node.name].ports.output = {};
                }

                this.instances[i] = node;
                logger.log('info', '%s: creating node', node.id);

                this.nodes[node.id] = new Node(node.id, this.map.nodeDefinitions[node.ns][node.name], node.ns + '::' + node.name + '-' + i);

                this.nodes[node.id].on('inputTimeout', this.handleInputTimeout.bind(this));
                this.nodes[node.id].on('nodeTimeout', this.handleNodeTimeout.bind(this));
                this.nodes[node.id].on('start', this.handleStart.bind(this));
                this.nodes[node.id].on('error', this.handleError.bind(this));
                this.nodes[node.id].on('complete', this.handleComplete.bind(this));
                this.nodes[node.id].on('require', this.handleRequire.bind(this));
                this.nodes[node.id].on('expose', this.handleExpose.bind(this));

                this.emit('nodeContext', this.nodes[node.id], node.context);

                this.nodes[node.id].on('output', this.output.bind(this));
            }
        };

        Actor.prototype.handleError = function (node, msg) {
            this.emit('error', node, msg);
        };

        Actor.prototype.handleExpose = function (node, key) {
            this.emit('expose', node, key);
        };

        Actor.prototype.handleRequire = function (node, mod) {
            this.emit('require', node, mod);
        };

        Actor.prototype.handleInputTimeout = function (node) {
            logger.log('info', '%s input time out occured need: %s, got: %s', node.identifier, node.inPorts, Object.keys(node.input).toString());

            this.emit('inputTimeout', node);
        };

        Actor.prototype.handleNodeTimeout = function (node) {
            this.emit('nodeTimeout', node);
        };

        Actor.prototype.handleStart = function (node) {
            this.emit('nodeStart', node);
        };

        Actor.prototype.handleComplete = function (node) {
            this.emit('nodeComplete', node);
        };

        Actor.prototype.run = function () {
            var i, iId;

            if (!this.contextProvider) {
                this.contextProvider = new DefaultProvider();
            }

            for (i in this.instances) {
                logger.log("info", "Adding context", this.instances[i].identifier);

                this.contextProvider.addContext(this.nodes[this.instances[i].id], this.map.nodes[i].context);
            }
        };

        Actor.prototype.getMapContext = function () {
            var i, contextNodes = {};

            for (i = 0; i < this.map.nodes.length; i++) {
                if (this.map.nodes[i].context) {
                    contextNodes[i] = this.map.nodes[i];
                }
            }

            return contextNodes;
        };

        Actor.prototype.getNodes = function () {
            return this.nodes;
        };

        Actor.prototype.getNode = function (id) {
            return this.nodes[id];
        };

        Actor.prototype.getInputMap = function () {
            return this.inputMap;
        };

        Actor.prototype.toDot = function () {
            var graph = [];
            graph.push("digraph {");
            graph.push('  label="' + this.map.description + '";');
            var source, target, source_name, target_name;
            var titles = {};
            this.map.links.forEach(function (d) {
                source = this.nodes[d.source];
                target = this.nodes[d.target];
                source_name = source.ns + '_' + source.name;
                target_name = target.ns + '_' + target.name;

                graph.push("  " + source_name + " -> " + target_name + " [label=\"out:" + d.out + "|in:" + d.in + "\"];");

                titles[source_name] = "  " + source_name + " " + '[label="' + source_name.replace("_", ":") + '"];';
                titles[target_name] = "  " + target_name + " " + '[label="' + target_name.replace("_", ":") + '"];';
            }.bind(this));

            for (var key in titles) {
                graph.push(titles[key]);
            }

            graph.push('}');

            return graph.join("\n");
        };
        return Actor;
    })(events.EventEmitter);
    Chiχ.Actor = Actor;
})(Chiχ || (Chiχ = {}));

module.exports = Chiχ.Actor;

