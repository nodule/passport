var jsongate = require('json-gate'),
  mSjson  = require('../schemas/map'),
  mapSchema = jsongate.createSchema(mSjson);


function InvalidIdException(message, id, obj) {
  this.message = message;
  this.id = id;
  this.obj = obj;
  this.name = "InvalidIdException";
}

/**
 * 
 * Validates the flow
 * 
 */
function validateFlow(flow) {
	
	if( flow.nodes.length > 0 && !flow.nodeDefinitions) {
		throw new Error("Cannot validate flow without nodeDefinitions");
	}

	mapSchema.validate(flow);

	_checkIds(flow);

	// make sure the id's are correct

}

/**
 * 
 * Check if we are not adding a (rotten) flow. Where there are id's which
 * overlap other ids in other flows.
 * 
 * This shouldn't happen but just perform this check always.
 * 
 * Currently it _will_ happen if you open the same flow twice. Saving those
 * seperatly can cause weird results ofcourse.
 * 
 * So also modify the code, so if you do this you will just go To the screen
 * which already has the flow open.
 * 
 * Add a growl like notication that this is done so.
 * 
 * This should be added to Actor
 * 
 */
function _checkIds(flow) {

	var i;

	// we will not add the flow, we will show a warning and stop adding the
	// flow.
	var knownIds = [], nodes = {}, node, link;
	for (i = 0; i < flow.nodes.length; i++) {

		node = flow.nodes[i];
		
		// nodeDefinition should be loaded
		if(!flow.nodeDefinitions[node.ns]) {
			throw new InvalidIdException("Can't find nodeDefinition namespace: " + node.ns, node.ns, node);
		}
		if(!flow.nodeDefinitions[node.ns][node.name]) {
			throw new InvalidIdException("Can't find nodeDefinition name: " + node.name, node.name, node);
		}

		knownIds.push(node.id);
		nodes[node.id] = node;
	}

	for (i = 0; i < flow.links.length; i++) {
		
		link = flow.links[i];

		// links should not point to non-existing nodes.
		if (knownIds.indexOf(link.source) === -1) {
			throw new InvalidIdException("Source node doesn't exist", link.source, link);
		}
		if (knownIds.indexOf(link.target) === -1) {
			throw new InvalidIdException("Target node doesn't exist", link.target, link);
		}
		
		// check if what is specified as port.out is an input port on the target
    source = nodes[link.source];
		target = nodes[link.target];

		if(!flow.nodeDefinitions[source.ns][source.name].ports.output[link.in]) {
			throw new InvalidIdException("No such output port at source: " + link.in, link.source, link);
		}
		
		if(!flow.nodeDefinitions[target.ns][target.name].ports.input[link.out]) {
			throw new InvalidIdException("No such input port on target: " + link.out, link.target, link);
		}
		
	}

	return true;

}

module.exports = validateFlow;