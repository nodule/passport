var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var events = require('events');
var vm = require('vm');

var jsongate = require('json-gate');
sprintf = require('sprintf').sprintf;

var Chiχ;
(function (Chiχ) {
    var Node = (function (_super) {
        __extends(Node, _super);
        function Node(id, node, identifier) {
            this.id = id;
            this._inputSchema = null;
            this.name = node.name;
            this.ns = node.ns;
            this.identifier = identifier || node.ns + ':' + node.name;
            this.port = {};
            this.ports = node.ports;
            this.sandbox = {};

            this.cycles = 0;

            if (!node.ports.input)
                node.ports.input = {};
            if (!node.ports.output)
                node.ports.output = {};

            this.inPorts = Object.keys(node.ports.input);
            this.outPorts = Object.keys(node.ports.output);
            this.inPortOpts = {};
            this.filled = 0;
            this.core = null;
            this.input = {};
            this.context = {};
            this.require = node.require;
            this.expose = node.expose;
            this.fn = node.fn;
            this.fillCore(node.fn, node.name);

            this.nodeTimeout = node.nodeTimeout || 3000;

            this.inputTimeout = typeof node.inputTimeout === "undefined" ? 3000 : node.inputTimeout;

            this._inputTimeout = null;

            this._inputSchema = jsongate.createSchema(this.ports.input);

            this.on('contextUpdate', function () {
                var port;
                for (port in this.context) {
                    logger.log('info', '%s: update context port:%s', this.identifier, port);
                    this.fill(port, this.context[port]);
                }
            });
        }
        Node.prototype.addContext = function (context) {
            this.context = context;
            this.emit('contextUpdate');
        };

        Node.prototype.addContextProperty = function (port, val) {
            this.context[port] = val;
            this.emit('contextUpdate');
        };

        Node.prototype.start = function () {
            var i, key;

            var sandbox = {};
            sandbox.input = this.input;
            sandbox.output = {};

            sandbox.console = console;

            var r = typeof window !== "undefined" ? χ : require;
            if (this.require) {
                for (key in this.require) {
                    this.emit('require', this, key);
                    sandbox[key] = r(key);
                }
            }

            if (this.expose) {
                for (i = 0; i < this.expose.length; i++) {
                    this.emit('expose', this, this.expose[i]);

                    if (this.expose[i] === "window") {
                        sandbox['win'] = window;
                    } else {
                        sandbox[this.expose[i]] = window[this.expose[i]];
                    }
                }
            }

            this.emit('start', this);

            var t = setTimeout(function () {
                this.emit('nodeTimeout', this);
            }.bind(this), this.nodeTimeout);

            this.cycles++;

            this.core.runInNewContext(sandbox);

            clearTimeout(t);

            this.output(sandbox.output);
        };

        Node.prototype.inputPortAvailable = function (port) {
            return typeof this.input[port] === "undefined";
        };

        Node.prototype.fillCore = function (fn, name) {
            this.emit('fillCore', fn, name);

            this.core = vm.createScript(fn, name);
        };

        Node.prototype.callbackWrapper = function () {
            var i, obj = {}, ports;
            ports = this.outPorts;
            for (i = 0; i < arguments.length; i++) {
                if (!ports[i])
                    throw new Error("Unexpected extra port, did you define the error port for this callback?");
                obj[ports[i]] = arguments[i];
            }

            this.output(obj);
        };

        Node.prototype.delegate = function (out) {
            var fn, method;

            fn = out.splice(0, 1).pop();
            method = out.splice(0, 1).pop();

            this.emit('branching', method);

            out.push(this.callbackWrapper.bind(this));
            fn[method].apply(fn, out);
        };

        Node.prototype.output = function (out) {
            var port;

            if (Array.isArray(out)) {
                this.delegate(out);
                return;
            }

            for (port in out) {
                this.emit('output', {
                    "port": port,
                    "out": out[port]
                }, this);
            }

            if (out.err) {
                this.emit('error', out.err);
            }

            this.freeInput();
        };

        Node.prototype.getStatus = function () {
            return this._status;
        };

        Node.prototype.setStatus = function (status) {
            this._status = status;
            this.emit("statusUpdate", this._status);
        };

        Node.prototype.fill = function (port, data, opts) {
            if (!this.inputPortAvailable(port)) {
                this.emit('portReject', this, port);
                return false;
            } else {
                if (this.validateInput(port, data)) {
                    this.fillPort(port, data, opts);
                    return true;
                }
            }
        };

        Node.prototype.validateData = function (port, data) {
            var type = this.ports.input[port].type;
            switch (type) {
                case 'string':
                case 'number':
                case 'boolean':
                case 'object':
                case 'array':
                case 'null':
                    type = type.charAt(0).toUpperCase() + type.slice(1);
                    return Object.prototype.toString.call(data) === '[object ' + type + ']';
                case 'integer':
                    return Object.prototype.toString.call(data) === '[object Number]' && data % 1 === 0;
                case 'any':
                    return true;
                default:
                    return true;
            }
        };

        Node.prototype.validateInput = function (port, data) {
            if (!this.ports.input.hasOwnProperty(port)) {
                this.emit('error', this, sprintf('info', '%s: Error: no such port:', this.identifier, port));

                logger.log('info', '%s: Error: no such port:', this.identifier, port);
                logger.log('info', '%s: Available ports:', this.identifier, Object.keys(this.ports.input));
                return false;
            }

            if (!this.validateData(port, data)) {
                var expected = this.ports.input[port].type;
                var real = typeof data;

                this.emit('error', this, sprintf("%s: Expected %s got %s", this.identifier, expected, real));

                logger.log('info', "%s: Expected %s got %s", this.identifier, expected, real);
                return false;
            }

            logger.log('info', '%s: validated input on %s port', this.identifier, port);
            return true;
        };

        Node.prototype.fillPort = function (port, data, opts) {
            var t;
            this.input[port] = data;
            this.inPortOpts[port] = opts || {};

            this.filled++;

            this.emit('portFill', this, port);

            if ((!this.inPortOpts[port].persist) && !this._inputTimeout && this.inputTimeout) {
                this._inputTimeout = setTimeout(function () {
                    this.emit('inputTimeout', this);
                }.bind(this), this.inputTimeout);
            }

            if (this.filled === this.inPorts.length) {
                if (this._inputTimeout) {
                    this.emit('clearTimeout', this);
                    clearTimeout(this._inputTimeout);
                }
                this.start();
            }
        };

        Node.prototype.freeInput = function () {
            var port, i;

            this.filled = 0;

            for (i = 0; i < this.inPorts.length; i++) {
                port = this.inPorts[i];
                if (!this.inPortOpts[port].persist) {
                    delete this.input[port];
                } else {
                    this.filled++;
                }
            }

            this.emit('complete', this);

            this.emit('output', { port: "event:complete", out: {} }, this);
        };
        return Node;
    })(events.EventEmitter);
    Chiχ.Node = Node;
})(Chiχ || (Chiχ = {}));

module.exports = Chiχ.Node;

