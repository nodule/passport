var nc = require('ncurses');
var origColors;

function backupColors() {
  if (!nc.hasColors)
    return;
  if (!origColors) {
    origColors = new Array(nc.maxColorPairs);
    for (var i=1; i<nc.maxColorPairs-1; i++)
      origColors[i] = [nc.colorFg(nc.colorPair(i)), nc.colorBg(nc.colorPair(i))];
  } else {
    for (var i=1; i<nc.maxColorPairs-1; i++) {
      origColors[i][0] = nc.colorFg(nc.colorPair(i));
      origColors[i][1] = nc.colorBg(nc.colorPair(i));
    }
  }
}

function restoreColors() {
  if (!nc.hasColors)
    return;
  for (var i=1; i<nc.maxColorPairs-1; i++)
    nc.colorPair(i, origColors[i][0], origColors[i][1]);
}

function times(str, num) {
  var ret = '';
  for (var i=0; i<num; i++)
    ret += str;
  return ret;
}

function pad(str, which, amount, padchar) {
  padchar = padchar || ' ';
  amount -= str.length;
  if (amount > 0) {
    var nbefore = 0, nafter = 0;
    if (which !== 'left') {
      if (which === 'center') {
        nbefore = Math.floor(amount/2);
        nafter = amount - nbefore;
      } else
        nbefore = amount;
    }
    str = times(padchar, nbefore) + str + times(padchar, nafter);
  }
  return str;
}

var Popup = function(height, width, position, title) {
  var win, pos;
  pos = position || 'center';
  pos = parsePosition(height, width, pos);

  win = new nc.Window(height, width, pos[0], pos[1]);
  if (title)
    win.frame(title);
  else if (title !== null)
    win.frame();

  return win;
};

exports.InputBox = function(text, options, cb) {
  backupColors();
  var win, lines = text.split('\n'), buffer = "", old_curs = nc.showCursor,
      width = 0, height = lines.length+4, textAlign,
      style = {
        colors: {
          fg: undefined,
          bg: undefined,
          input: {
            fg: undefined,
            bg: undefined
          }
        }
      }, fnDraw;
  if (!cb && typeof options === 'function')
    cb = options;
  if (typeof options !== 'object')
    options = {};
  textAlign = options.textAlign || 'center';
  extend(true, style, options.style);

  // Fit to the content
  for (var i=0,len=lines.length; i<len; i++)
    if (lines[i].length > width)
      width = lines[i].length;
  width += 4;

  fnDraw = function() {
    var isRedraw = (win ? true : false);
    if (isRedraw) {
      //win.move(boxY, boxX);
      //nc.redraw();
    } else {
      win = Popup(height, width, options.pos);
      if (nc.hasColors) {
        if (!style.colors)
          style.colors = {};
        style.colors.fg = parseColor(style.colors.fg, nc.colorFg(nc.colorPair(0)));
        style.colors.bg = parseColor(style.colors.bg, nc.colorBg(nc.colorPair(0)));
        if (!style.colors.input)
          style.colors.input = {};
        style.colors.input.fg = parseColor(style.colors.input.fg, style.colors.bg);
        style.colors.input.bg = parseColor(style.colors.input.bg, style.colors.fg);

        nc.colorPair(nc.maxColorPairs-1, style.colors.fg, style.colors.bg);
        nc.colorPair(nc.maxColorPairs-2, style.colors.input.fg, style.colors.input.bg);
        win.attrset(nc.colorPair(nc.maxColorPairs-1));
        win.bkgd = ' '|nc.colorPair(nc.maxColorPairs-1);
      }
      win.on('inputChar', function(c, i) {
        if (i === nc.keys.ESC)
          buffer = undefined;
        else if (i !== nc.keys.NEWLINE) {
          if (i === nc.keys.BACKSPACE && win.curx > 1) {
            var prev_x = win.curx-1;
            win.delch(height-2, prev_x);
            buffer = buffer.substring(0, prev_x-1) + buffer.substr(prev_x);
            win.insch(height-2, width-2, 32);
            win.cursor(height-2, prev_x);
          } else if (i === nc.keys.DEL && win.curx > 0 && win.curx < width-1) {
            var prev_x = win.curx;
            win.delch(height-2, win.curx);
            buffer = buffer.substring(0, win.curx-1) + buffer.substr(win.curx);
            win.insch(height-2, width-2, 32);
            win.cursor(height-2, prev_x);
          } else if (i === nc.keys.LEFT && win.curx > 1)
            win.cursor(height-2, win.curx-1);
          else if (i === nc.keys.RIGHT && win.curx < buffer.length+1)
            win.cursor(height-2, win.curx+1);
          else if (i === nc.keys.END)
            win.cursor(height-2, buffer.length+1);
          else if (i === nc.keys.HOME)
            win.cursor(height-2, 1);
          else if (i >= 32 && i <= 126 && win.curx < width-1) {
            win.echochar(i);
            buffer += c;
          }
          if (nc.hasColors) {
            var x = win.curx;
            win.chgat(height-2, 1, width-2, nc.attrs.NORMAL, nc.maxColorPairs-1);
            win.chgat(height-2, 1, buffer.length, nc.attrs.NORMAL, nc.maxColorPairs-2);
            win.cursor(height-2, x);
          }
          win.refresh();
          return;
        }
        nc.showCursor = old_curs;
        win.close();
        restoreColors();
        if (cb)
          process.nextTick(function(){ cb(buffer); });
        //process.removeListener('SIGWINCH', fnDraw);
      });
    }

    var ln = 1;
    for (var i=0,len=lines.length; i<len; i++,ln++) {
      lines[i] = pad(lines[i], textAlign, width-4);
      win.addstr(ln, 2, lines[i]);
    }

    win.hline(ln++, 1, width-2);
    win.cursor(height-2, 1);
    nc.showCursor = true;

    if (options.title)
      win.frame(options.title);
    else
      win.frame();

    nc.redraw();
  };
  fnDraw();
  //process.on('SIGWINCH', fnDraw);
};


function parseColor(color, def) {
  var ret = undefined;

  if (typeof color === 'string') {
    if (typeof nc.colors[color.toUpperCase()] !== 'undefined')
      ret = nc.colors[color.toUpperCase()];
    else {
      try {
        ret = parseInt(color);
      } catch (err) {}
    }
  } else if (typeof color === 'number')
    ret = color;
  else if (typeof def !== 'undefined')
    ret = def;

  return ret;
}

function parsePosition(height, width, pos) {
  var boxY = 0, boxX = 0;
  if (typeof pos === 'string') {
    if (pos === 'top' || pos === 'topleft' || pos === 'topright')
      boxY = 0;
    else if (pos === 'bottom' || pos === 'bottomleft' || pos === 'bottomright')
      boxY = nc.lines-height;
    else
      boxY = Math.floor(nc.lines/2)-Math.floor(height/2);

    if (pos === 'left' || pos === 'topleft' || pos === 'bottomleft')
      boxX = 0;
    else if (pos === 'right' || pos === 'topright' || pos === 'bottomright')
      boxX = nc.cols-width;
    else
      boxX = Math.floor(nc.cols/2)-Math.floor(width/2);
  } else if (Array.isArray(pos)) {
    boxY = pos[0];
    boxX = pos[1];
  } else if (typeof pos === 'number')
    boxY = boxX = Math.floor(pos);
  return [boxY, boxX];
}

/**
 * Adopted from jquery's extend method. Under the terms of MIT License.
 *
 * http://code.jquery.com/jquery-1.4.2.js
 *
 * Modified by Brian White to use Array.isArray instead of the custom isArray method
 */
function extend() {
  // copy reference to target object
  var target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options, name, src, copy;
  // Handle a deep copy situation
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    // skip the boolean and the target
    i = 2;
  }
  // Handle case when target is a string or something (possible in deep copy)
  if (typeof target !== "object" && !typeof target === 'function')
    target = {};
  var isPlainObject = function(obj) {
    // Must be an Object.
    // Because of IE, we also have to check the presence of the constructor property.
    // Make sure that DOM nodes and window objects don't pass through, as well
    if (!obj || toString.call(obj) !== "[object Object]" || obj.nodeType || obj.setInterval)
      return false;
    var has_own_constructor = hasOwnProperty.call(obj, "constructor");
    var has_is_property_of_method = hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf");
    // Not own constructor property must be Object
    if (obj.constructor && !has_own_constructor && !has_is_property_of_method)
      return false;
    // Own properties are enumerated firstly, so to speed up,
    // if last one is own, then all properties are own.
    var last_key;
    for (key in obj)
      last_key = key;
    return typeof last_key === "undefined" || hasOwnProperty.call(obj, last_key);
  };
  for (; i < length; i++) {
    // Only deal with non-null/undefined values
    if ((options = arguments[i]) !== null) {
      // Extend the base object
      for (name in options) {
        src = target[name];
        copy = options[name];
        // Prevent never-ending loop
        if (target === copy)
            continue;
        // Recurse if we're merging object literal values or arrays
        if (deep && copy && (isPlainObject(copy) || Array.isArray(copy))) {
          var clone = src && (isPlainObject(src) || Array.isArray(src)) ? src : Array.isArray(copy) ? [] : {};
          // Never move original objects, clone them
          target[name] = extend(deep, clone, copy);
        // Don't bring in undefined values
        } else if (typeof copy !== "undefined")
          target[name] = copy;
      }
    }
  }
  // Return the modified object
  return target;
};
